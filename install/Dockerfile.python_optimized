# Define build args (used for all stages) here
# These args can be overridden during build by --build-args NAME=VAL
# see: https://docs.docker.com/engine/reference/builder/#arg

ARG PYTHON_VERSION=3.10-slim

# pin base dependency versions to build the base image
# poetry as the base dependency
ARG POETRY_VERSION=1.6.1

# PYTHON_WHEEL_PATH is used to store the built wheels
ARG PYTHON_WHEEL_PATH=/var/cache/python/wheels

# use a common path for all poetry data and virtualenvs to share them between stages
ARG POETRY_DATA_DIR=/usr/local/poetry/data
# poetry stores the virtualenvs by default under the cache path, maybe it's better to keep all poetry data in one place
ARG POETRY_CACHE_DIR=/usr/local/poetry/cache

# set POETRY_INSTALL_OPTS='--no-root --with dev' to build with dev dependencies
ARG POETRY_INSTALL_OPTS='--no-root --with dev'  # not installing the app itself in the venv to keep venv and app in separate paths

################################################################################
# Base stage
################################################################################
# base stage defines the base for other stages, to set defaults and define build args

FROM python:${PYTHON_VERSION} as base-python

ARG PYTHON_WHEEL_PATH

ARG POETRY_VERSION
ENV POETRY_VERSION=${POETRY_VERSION}

ARG POETRY_DATA_DIR
ENV POETRY_DATA_DIR=${POETRY_DATA_DIR}
ARG POETRY_CACHE_DIR
ENV POETRY_CACHE_DIR=${POETRY_CACHE_DIR}

ENV APP_PATH=/usr/src/app
WORKDIR ${APP_PATH}

RUN mkdir -p ${PYTHON_WHEEL_PATH} \
    && mkdir -p ${POETRY_DATA_DIR} \
    && mkdir -p ${POETRY_CACHE_DIR} \
    && mkdir -p ${APP_PATH}

################################################################################
# Build stage
################################################################################

FROM base-python as app-build-stage

# install all build dependencies to build wheels
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        build-essential

# explicitly download base dependencies (poetry, etc.) wheels, then install them
# keep the wheels so they're available for the next stage
RUN pip wheel --wheel-dir ${PYTHON_WHEEL_PATH} poetry==${POETRY_VERSION} \
    && pip install --no-cache-dir --no-index --find-links=${PYTHON_WHEEL_PATH} ${PYTHON_WHEEL_PATH}/poetry*

# copy application dependency specs
COPY ./pyproject.toml ./poetry.lock ${APP_PATH}/

# build and install the application dependencies in a virtualenv
# cleanup cached files as build is done, since these paths are copied into the next stage.
# no fail on cleanup.
RUN poetry install ${POETRY_INSTALL_OPTS} \
    && (poetry cache clear --all --no-interaction PyPI || true) \
    && (poetry cache clear --all --no-interaction _default_cache || true)

################################################################################
# Run stage
################################################################################

FROM base-python as app-run-stage

# install required runtime dependencies, and cleanup cached files for a smaller layer
RUN apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false \
  && rm -rf /var/lib/apt/lists/*

# copy all base dependency wheel files from build stage, then install them
COPY --from=app-build-stage ${PYTHON_WHEEL_PATH} ${PYTHON_WHEEL_PATH}
RUN pip install --no-cache-dir --no-index --find-links=${PYTHON_WHEEL_PATH} ${PYTHON_WHEEL_PATH}/poetry* \
    && rm -rf ${PYTHON_WHEEL_PATH}

# now copy the application dependencies (pre-built virutalenv)
COPY ./pyproject.toml ./poetry.lock ${APP_PATH}/
COPY --from=app-build-stage ${POETRY_DATA_DIR} ${POETRY_DATA_DIR}
COPY --from=app-build-stage ${POETRY_CACHE_DIR} ${POETRY_CACHE_DIR}

ARG UID=1000
ARG GID=1000

ARG MYUSER=container_user
